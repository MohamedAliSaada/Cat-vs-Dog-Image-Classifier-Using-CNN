# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ut8eOVka6y44S5u5NaXwIa0IXqF7yVoC
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense,Flatten,Conv2D,MaxPooling2D,Dropout
from IPython.display import display
from PIL import Image
from io import BytesIO

#load my dataset from hugging face.
splits = {'train': 'data/train-00000-of-00001.parquet', 'test': 'data/test-00000-of-00001.parquet'}
df = pd.read_parquet("hf://datasets/Bingsu/Cat_and_Dog/" + splits["train"])
#df_v  =pd.read_parquet("hf://datasets/Bingsu/Cat_and_Dog/"+splits['test'])


#use subset of data
df = df.sample(frac=1).reset_index(drop=True)
df=df[0:4000]

#set my image parameters
img_h=224
img_w=224
img_c=3
num_labels=2

# preprocessing my data
def img_to_array(x):
  img_b= BytesIO(x['bytes'])      #when use with df column elemnt x by x.
  img = Image.open(img_b)         #convert to img via PIL.
  img= img.resize((img_h,img_w))
  img_arr = np.array(img)/ 255.0  #make rescale.
  return img_arr


# Convert images to tensors and stack
x_train = np.stack(df['image'].apply(img_to_array).tolist(), axis=0).astype('float32')
#x_eval  = np.stack(df_v['image'].apply(img_to_array).tolist(), axis=0).astype('float32')

# Convert labels
y_train = df['labels'].values.astype('int8')[0:4000]
#y_eval = df_v['labels'].values.astype('int8')


# Define the model architecture
Module=Sequential([
    Conv2D(filters=32,kernel_size=(3,3),strides=(1,1),activation='relu',padding='same',
    input_shape=(img_h,img_w,img_c),kernel_initializer='he_normal'
    ),
    MaxPooling2D(pool_size=(2,2)),


    Conv2D(64,(3,3),activation='relu',kernel_initializer='he_normal'),
    MaxPooling2D(pool_size=(2,2)),


    Conv2D(128,(3,3),activation='relu',kernel_initializer='he_normal'),
    MaxPooling2D(pool_size=(2,2)),




    Flatten(),
    Dense(64,activation='relu'),
    Dropout(0.5),
    Dense(32,activation='relu'),
    Dropout(0.5),
    Dense(1,activation='sigmoid')     # For binary classification (cat vs dog)

])

#get module summary.
#Module.summary()

#make compile setting.
Module.compile(
    optimizer='adamW',
    loss='binary_crossentropy',
    metrics=['accuracy']

)

#run and train ower Module.
history=Module.fit(
    x_train,
    y_train,
    epochs=15,
    validation_split=.1,
    batch_size=128
)


plt.figure()

plt.subplot(2,2,1)
plt.plot(history.history['accuracy'],color='r',label='accuracy of training')
plt.xlabel("epochs")
plt.ylabel("accuracy")
plt.legend()
plt.grid(True)

plt.subplot(2,2,2)
plt.plot(history.history['val_accuracy'],color='b',label='accuracy of validation')
plt.xlabel("epochs")
plt.ylabel("accuracy")
plt.legend()
plt.grid(True)


plt.subplot(2,2,3)
plt.plot(history.history['loss'],color='r',label='loss of training')
plt.xlabel("epochs")
plt.ylabel("loss")
plt.legend()
plt.grid(True)

plt.subplot(2,2,4)
plt.plot(history.history['val_loss'],color='b',label='loss of validation')
plt.xlabel("epochs")
plt.ylabel("loss")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

Module.save('Module.keras')

#load and test module.
from tensorflow.keras.models import load_model

module = load_model('Module.keras')

img_paths=['/content/1.jpg','/content/2.jpg','/content/3.jpg','/content/4.jpg','/content/5.jpg','/content/6.jpg']

def prepare_img(path):
  img=Image.open(path)
  img=img.resize((224,224))
  arr = np.array(img) / 255.0
  return arr

True_labels=[0,0,0,0,1,1]
img=[]
for p in img_paths:
  img.append(prepare_img(p))

images = np.stack(img,axis=0).astype('float32')
pred = module(images)
pred=np.array(pred)
pred_labels = (pred > 0.5).astype(int).flatten()

fig , axis =  plt.subplots(2,3,figsize=(12,5))

for i , ax in enumerate(axis.flat):
  ax.imshow(images[i])
  ax.set_title(f'actual:{True_labels[i]},predict:{pred_labels[i]}')

plt.tight_layout()
plt.show()

